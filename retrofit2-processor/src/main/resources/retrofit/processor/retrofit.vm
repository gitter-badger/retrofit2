## Template for each generated Retrofit_Foo class.
## This template uses the Apache Velocity Template Language (VTL).
## The variables ($pkg, $props, and so on) are defined by the fields of MutableRetrofitTemplateVars.
##
## Comments, like this one, begin with ##. The comment text extends up to and including the newline
## character at the end of the line. So comments also serve to join a line to the next one.
## Velocity deletes a newline after a directive (#if, #foreach, #end etc) so ## is not needed there.
## That does mean that we sometimes need an extra blank line after such a directive.
##
## A post-processing step will remove unwanted spaces and blank lines, but will not join two lines.

#if (!$pkg.empty)
package $pkg;
#end

#foreach ($i in $imports)
import $i;
#end

import org.json.JSONObject;
import org.json.JSONException;

import rx.Observable;
import rx.Subscriber;
import rx.functions.*;

import com.bluelinelabs.logansquare.LoganSquare;

import android.util.Log;

import java.util.List;

import com.squareup.okhttp.*;
import java.io.IOException;

/**
 * @see "https://github.com/square/okhttp/wiki/Recipes"
 */
${gwtCompatibleAnnotation}
public final class $subclass$formalTypes extends $origClass$actualTypes {

    final OkHttpClient client;
    public static final String _MIME_APP_JSON = "applications/json";
    public static final String _CHARSET_UTF8 = "charset=utf-8";
    public static final String _MIME_APP_JSON_CHARSET_UTF8 = _MIME_APP_JSON + "; " + _CHARSET_UTF8;

## Constructor

    public $subclass() {
        client = new OkHttpClient();

        /*
        int cacheSize = 10 * 1024 * 1024; // 10 MiB
        Cache cache = new Cache(cacheDirectory, cacheSize);

        client = new OkHttpClient();
        client.setCache(cache);
        */
    }


## Property getters

#foreach ($p in $props)

    @Override
    ${p.access}${p.type} ${p.getter}(${p.args}) {

// if ($p.path.matches("^http://") && $p.path.matches("^https://"))

        String _url = "${p.path}";
        if (!_url.startsWith("http://") && !_url.startsWith("https://")) {
            _url = "${baseUrl}" + _url;
        }

        Request.Builder requestBuilder = new Request.Builder().url(_url);

    #if ($p.get)

    #elseif ($p.post)
        #if ($p.body)

        String jsonString = null;
        try {
            jsonString = LoganSquare.serialize($p.body);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
        //if (jsonString == null) throw new NullPointerException();
        requestBuilder.post(RequestBody.create(MediaType.parse(_MIME_APP_JSON_CHARSET_UTF8), jsonString));

        #elseif (!$p.fields.isEmpty())

        FormEncodingBuilder formBuilder = new FormEncodingBuilder();

            #foreach ($field in $p.fields.entrySet())

        formBuilder.add("$field.key", $field.value);

            #end

        requestBuilder.post(formBuilder.build());

        #end
    #elseif ($p.put)
        #if (!$p.parts.isEmpty())

        MultipartBuilder partsBuilder = new MultipartBuilder().type(MultipartBuilder.FORM);

            #foreach ($part in $p.parts.entrySet())

                #if ($part.value.type == "")

        partsBuilder.addPart(
            Headers.of("Content-Disposition", "form-data; name=\"${p.part.key}\""),
            RequestBody.create(null, ${part.value.name}));

                #else

        partsBuilder.addPart(
            Headers.of("Content-Disposition", "form-data; name=\"${p.part.key}\""),
            RequestBody.create(${part.value.type}, ${part.value.name}));

                #end
            #end

        requestBuilder.put(partsBuilder.build());

        #end
    #elseif ($p.delete)


        requestBuilder.delete();

    #end

    #foreach ($header in $p.headers.entrySet())

        requestBuilder.addHeader("$header.key", "$header.value");

    #end

        return Observable.create(new OnSubscribeResponse(client, requestBuilder.build())).map(new Func1<Response, String>() {
            @Override public String call(Response response) {
                try {
                    return response.body().string();
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
            }
        }).filter(new Func1<String, Boolean>() {
            @Override public Boolean call(String json) {
                return json != null;
            }
            /*
        }).map(new Func1<String, $p.typeArgs>() {
            @Override public $p.typeArgs call(String json) {
                // TODO Using RetrofitConveter
                try {
                    return LoganSquare.parse(json, AutoJson_${p.typeArgs}.class);
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
            }
            */
        }).map(new Func1<String, List<? extends $p.typeArgs>>() {
            @Override public List<? extends $p.typeArgs> call(String json) {
                // TODO Using RetrofitConveter
                try {
                    System.out.println(json);
                    return LoganSquare.parseList(json, AutoJson_${p.typeArgs}.class);
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
            }
        }).filter(new Func1<List<? extends $p.typeArgs>, Boolean>() {
            @Override public Boolean call(List<? extends $p.typeArgs> list) {
                return list != null;
            }
        }).flatMap(new Func1<List<? extends $p.typeArgs>, Observable<$p.typeArgs>>() {
            @Override public Observable<$p.typeArgs> call(List<? extends $p.typeArgs> list) {
                return Observable.from(list);
            }
        }).filter(new Func1<$p.typeArgs, Boolean>() {
            @Override public Boolean call($p.typeArgs object) {
                return object != null;
            }
        });
    }

#end

    // TODO onUnSubscribe to call.cancel();
    public static class OnSubscribeResponse implements Observable.OnSubscribe<Response> {
        final Request request;
        final OkHttpClient client;

        public OnSubscribeResponse(OkHttpClient client, Request request) {
            this.request = request;
            this.client = client;
        }

        @Override
        public void call(final Subscriber<? super Response> sub) {
            try {
                client.newCall(request).enqueue(new Callback() {
                    @Override public void onFailure(Request request, IOException e) {
                        sub.onError(e);
                    }
                    @Override public void onResponse(Response response) {
                        sub.onNext(response);
                        sub.onCompleted();
                    }
                });
            } catch (Exception e) {
                sub.onError(e);
            }
        }
    }

}
